\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}

In this thesis, we implemented a new algorithm for isometric reconciliation which builds on an existing approach and introduces two new algorithms for partial aspects of the problem. Our software takes a rooted species tree with exact branch lengths and a rooted or unrooted gene tree with inexact branch lengths as an input. The output of our software is one or more reconciled gene trees which minimize the number of duplications and gene losses.

We firstly analysed current approaches of solving the problem of reconciliation in general. We divided them into three main groups: scoring, probabilistic and isometric gene tree reconciliation. We made an overview of existing software for the scoring and probabilistic reconciliation. We further focused on the isometric reconciliation which we subdivide into two variants. The first variant is the isometric reconciliation with exact branch lengths introduced by Ma et al.~\cite{ma} in 2008 and later corrected by Brejov치 et al.~\cite{brejova}, who suggested extension for reconciliation of unrooted gene tree and species tree in running time $O(N^5 log N)$. The second variant is isometric reconciliation with inexact branch lengths introduced by Chl치dek~\cite{chladek_thesis} suggesting algorithms to infer the most parsimonious reconciliation for a rooted species tree and a semi-rooted or unrooted gene tree with the running time $O(N^4 log N)$.

We built on the algorithms from~\cite{chladek_thesis} and created a new algorithm for rooting an unrooted gene tree. For each edge in the unrooted gene tree, it semi-roots the gene tree and subdivides the root edge by a given step. The running time of the rooting algorithm is $O(N^2 + P)$, where $N$ is the number of edges in the unrooted gene tree and $P$ is the number of possible roots for all edges in the unrooted gene tree. The second algorithm is for counting the evolutionary events in the gene tree and requires precomputed variables by the two-pass algorithm by~\cite{chladek_thesis}. For each node in the gene tree, we count the duplications in the gene node and gene losses on the edge from the gene node to its parent. We split the algorithm into preprocessing and the main algorithm. The running time of preprocessing is $O(N^2)$ and of the main algorithm is $O(N)$. Therefore, the total running time of isometric reconciliation with our two algorithms and the two-pass algorithm~\cite{chladek_thesis} is $O(N^2)$ for a rooted gene tree and $O(N^4 + N^2P)$ for an unrooted gene tree.

The previous algorithm by Chl치dek~\cite{chladek_thesis} requires advanced data structures that are not used in our algorithms. By applying these data structures, we can reduce the running time complexity. However, we can not always guarantee to find the optimal reconciliation solution as the edges are subdivided with a given step while rooting the gene tree.

Created algorithms were implemented into a source code by Chl치dek~\cite{chladek_thesis} which resulted in an isometric reconciliation software with a command-line interface. We made several changes in the original source code and additions that we highlighted and described.

Finally, we tested the implemented software on simulated and real datasets and compared the results to other software. The simulated dataset consisted of two species trees with 1000 simulated gene families, where the gene trees are rooted. We run the software without and with rerooting the gene trees. Without rerooting the gene trees, we were testing the impact of different tolerance settings on the reconciliation. We found that the best tolerance needs to be by one decimal place shorter than the number of decimal places in the edge length in a rooted gene tree if the branch lengths are known exactly. Our software was the fastest in inferring the isometric reconciliation. With rerooting the gene tree, we were testing the impact of the tolerance and step settings on the reconciliation. We found the optimal tolerance and step settings for the simulated dataset. In both clades, our software infers the best solution compared to the other software two times. The real dataset consisted of 5351 alignments which we transformed into unrooted trees. Our software had comparable results to other software.
